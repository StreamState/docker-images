apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  #generateName: spark-streaming-ci-  # Name of this Workflow
  name: spark-streaming-ci
spec:
  serviceAccountName: argo-events-sa # TODO! create different service account than from line 7 and give minimum permissions
  entrypoint: main    
  #imagePullSecrets: 
  #- name: docker-cfg-read  
  volumeClaimTemplates:
  - metadata:
      name: work
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 64Mi
  templates:
  - name: main
    dag:
      tasks:
      - name: B
        # dependencies: [A]
        template: build-docker-image

  - name: build-jar     
    inputs:
      parameters:
        - name: scalacode
    
    container:
      volumeMounts:
      - mountPath: /work # hope this persists across containers/steps...
        name: work
      image: gcr.io/streamstatetest/scalacompile:v0.5.0
      
      command: [sh, -c]
      args: ["echo {{inputs.parameters.scalacode}} | base64 --decode > src/main/scala/custom.scala; sbt assembly; cp streamstate.jar /work/streamstate.jar; ls -la /work;"]
      #workingDir: /work
    archiveLocation: # maybe delete this...
      archiveLogs: false

  - name: build-docker-image
    inputs:
      parameters:
        # Name of the image to push
        - name: image
          value: gcr.io/streamstatetest/testorg/scalaapp:v0.1.0 # TODO!  specify tag version
        - name: dockerfileline1 
          value: FROM gcr.io/streamstatetest/sparkbase:v0.1.0
        #- name: dockerfileline2 
        #  value: COPY streamstate.jar /opt/spark/work-dir/streamstate.jar
        - name: dockerfileline3
          value: ENTRYPOINT ["/opt/entrypoint.sh"]
    volumes:
      - name: docker-config
        secret:
          secretName: docker-creds
    container:
      image: docker:19.03.13 
      command: [sh, -c]
      workingDir: /work
      args: [
        "ls -la /.docker; cat /.docker/config.json; \
        echo {{inputs.parameters.dockerfileline1}} > Final.Dockerfile; \
        echo {{inputs.parameters.dockerfileline3}} >> Final.Dockerfile; \
        until docker ps; do sleep 3; done; \
        cd /work && docker --config /.docker/ build . -f Final.Dockerfile -t {{inputs.parameters.image}} && docker --config /.docker/ push {{inputs.parameters.image}}; "]
      volumeMounts:
      - mountPath: /work # hope this persists across containers/steps...
        name: work
      - name: docker-config
        mountPath: "/.docker/config.json" 
        #mountPath: /.docker
        subPath: ".dockerconfigjson"
      env:
      - name: DOCKER_HOST
        value: 127.0.0.1 # or tcp://localhost:2375 ?
      - name: DOCKER_CONFIG
        value: /.docker
    sidecars:
    - name: dind
      image: docker:19.03.13-dind
      env:
        - name: DOCKER_TLS_CERTDIR
          value: ""
      securityContext:
        privileged: true
      # mirrorVolumeMounts will mount the same volumes specified in the main container
      # to the sidecar (including artifacts), at the same mountPaths. This enables
      # dind daemon to (partially) see the same filesystem as the main container in
      # order to use features such as docker volume binding.
      mirrorVolumeMounts: true